// ------------------------------------------------------------------------------
// DelphiQuake, Copyright (C) 2005-2011 by Jim Valavanis
//  E-Mail: jimmyvalavanis@yahoo.gr
//
// Copyright (C) 1996-1997 Id Software, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not,  write to the Free Software
// Foundation,  Inc., 59 Temple Place - Suite 330,  Boston,  MA  02111-1307, USA.
//
// ------------------------------------------------------------------------------

{$I dquake.inc}

{$Z4}

unit gl_defs;

interface

uses
  q_delphi,
  q_vector,
  OpenGL12,
  bspconst,
  gl_planes;

type
// Function prototypes for the Texture Object Extension routines
  BINDTEXFUNCPTR = procedure(num: TGLenum; u: TGLuint); stdcall;


// r_local.h -- private refresh defs
const
  ALIAS_BASE_SIZE_RATIO = (1.0 / 11.0);
          // normalizing factor so player model works out to about
          //  1 pixel per triangle
  MAX_LBM_HEIGHT = 480;

  TILE_SIZE = 128; // size of textures generated by R_GenTiledSurf

  SKYSHIFT = 7;
  SKYSIZE = 1 shl SKYSHIFT;
  SKYMASK = (SKYSIZE - 1);

  BACKFACE_EPSILON = 0.01;

(*
void R_TimeRefresh_f (void);
void R_ReadPointFile_f (void);
texture_t *R_TextureAnimation (texture_t *base);
*)

type
  PPsurfcache_t = ^Psurfcache_t;
  Psurfcache_t = ^surfcache_t;
  surfcache_t = record
    next: Psurfcache_t;
    owner: PPsurfcache_t; // NULL is an empty chunk of memory
    lightadj: array[0..MAXLIGHTMAPS - 1] of integer; // checked for strobe flush
    dlight: integer;
    size: integer; // including header
    width: unsigned;
    height: unsigned; // DEBUG only needed for debug
    mipscale: single;
    texture: Ptexture_t; // checked for animating textures
    data: array[0..3] of byte; // width*height elements
  end;


  drawsurf_t = record
    surfdat: PByte; //Ppixel_t;  // destination for generated surface
    rowbytes: integer; // destination logical width in bytes
    surf: Pmsurface_t; // description for surface to generate
    lightadj: array[0..MAXLIGHTMAPS - 1] of integer;
              // adjust for lightmap levels for dynamic lighting
    texture: Ptexture_t; // corrected for animating textures
    surfmip: integer; // mipmapped ratio of surface texels / world pixels
    surfwidth: integer; // in mipmapped texels
    surfheight: integer; // in mipmapped texels
  end;
  Pdrawsurf_t = ^drawsurf_t;


  ptype_t = (
    pt_static,
    pt_grav,
    pt_slowgrav,
    pt_fire,
    pt_explode,
    pt_explode2,
    pt_blob,
    pt_blob2
    );


// !!! if this is changed, it must be changed in d_ifacea.h too !!!
type
  Pparticle_t = ^particle_t;
  particle_t = record
// driver-usable fields
    org: TVector3f;
    color: single;
// drivers never touch the following fields
    next: Pparticle_t;
    vel: TVector3f;
    ramp: single;
    die: single;
    _type: ptype_t;
  end;

  particle_tArray = array[0..$FFFF] of particle_t;
  Pparticle_tArray = ^particle_tArray;

const
// Multitexture
  TEXTURE0_SGIS = $835E;
  TEXTURE1_SGIS = $835F;

type
  lpMTexFUNC = procedure(num: TGLenum; f1: TGLfloat; f2: TGLfloat); stdcall;
  lpSelTexFUNC = procedure(num: TGLenum); stdcall;


var
  qglMTexCoord2fSGIS: lpMTexFUNC = nil;
  qglSelectTextureSGIS: lpSelTexFUNC = nil;

  mtexenabled: qboolean = false;

var
  particletexture: integer; // little dot for particles

implementation

end.

